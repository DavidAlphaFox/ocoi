<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>designphilosophy (ocoi.designphilosophy)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">ocoi</a> &#x00BB; designphilosophy</nav><h1 id="design-philosophy"><a href="#design-philosophy" class="anchor"></a>Design philosophy</h1><p>OCaml On Ice's design borrows a lot from Ruby on Rails. This applies both to its abstract principles such as using sensible defaults to minimise boilerplate and speed up development, and to specifics such as the project directory structure and names of <code>ocoi</code> commands. However, it does differ from Rails and similar frameworks in several significant ways, which are discussed below.</p><nav class="toc"><ul><li><a href="#no-orm">No ORM</a></li><li><a href="#for-apis">For APIs</a></li><li><a href="#deploying-ice-apps">Deploying Ice apps</a></li></ul></nav></header><h2 id="no-orm"><a href="#no-orm" class="anchor"></a>No ORM</h2><p>Unlike most modern web frameworks, Ice doesn't have an ORM. Instead it uses code generation to avoid the need to write repetitive SQL queries for CRUD operations by hand. There are various reasons for this choice. Some of them are consequences of using OCaml, for instance it would be odd to use an <i>Object</i>-Relational Mapping in a language where classes are usually a anti-pattern. Others are more general, for instance those described in the classic blog post <a href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/">The Vietnam of Computer Science</a>.</p><h2 id="for-apis"><a href="#for-apis" class="anchor"></a>For APIs</h2><p>Frameworks such as Rails and Django are primarily designed for building apps with a Model-View-Controller structure, where the views are template files that are filled in by controllers and turned into HTML by the server. This produces apps where the frontend and backend are tightly integrated.</p><p>In comparison, Ice is designed for building REST APIs that are then consumed by one or more frontends, with the full application being a combination of the Ice backend and loosely integrated frontends. So while it still has the concepts of models and controllers, you do not explicitly define views (the functionality of the View layer in MVC is spread between the frontend, Ice library code, user controller code and user &quot;model&quot; code).</p><p>Furthermore, it is specifically designed for building APIs to be used by frontends written in OCaml (for instance using ReasonML/BuckleScript or js_of_ocaml) with some code shared between backend and frontend. This means that models and controllers in an Ice app don't correspond exactly to the Model and Controller layers of MVC. For instance, the database interfacing parts of a Model are implemented in the <code>app/queries</code> directory in Ice not <code>app/models</code> (since they are irrelevant to frontend code) and conversely a model in <code>app/models</code> will implement JSON serialisation even though that doesn't really belong in a Model (since it is also needed in frontend code).</p><p>Similarly, Rails and Django include functionality for serving static content. Ice doesn't have this; in cases where it does make sense to serve static content from a server that is also providing an API you can do it manually with Opium, but typically it should be served from a dedicated source (e.g. another server or a CDN).</p><h2 id="deploying-ice-apps"><a href="#deploying-ice-apps" class="anchor"></a>Deploying Ice apps</h2><p>Since OCaml is a compiled language that isn't widely used for building web apps, deploying Ice projects is different in various ways from deploying ones that use popular interpreted languages like Ruby and Python. Deploying an Ice app is a two-step process. First it must be built, which means compiling the entry point <code>main.ml</code> into an executable. This executable is the server, which can then be deployed somewhere (potentially behind a load balancer or similar, and probably accompanied by a Postgresql database). This can be done natively but Ice projects also support doing both steps in Docker. Building is done using <code>dune</code> and if building with Docker the dependencies are managed with <code>opam</code>. The actual server functionality is implemented by Opium which uses cohttp and lwt, but this could change in the future.</p></div></body></html>